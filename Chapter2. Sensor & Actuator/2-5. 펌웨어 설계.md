# 펌웨어 설계

## Auto 제어기 와 장치 연결 구성 
Auto 제어기와 XHome 의 장치는 다양한 방식으로 연결되어 있습니다. 센서의 종류, 액츄에이터의 종류에 따라 연결 방식이 상이하며 각 연결 방식에 따른 제어가 모두 다릅니다. 

### 액츄에이터 연결 구성 
XHome 에서 제어가능한 액츄에이터를 정리하면 다음과 같습니다. 

- Lamp 5ea 
- Fan 5ea 
- GasBreaker 1ea 
- DoorLock 1ea 
- Curtain 1ea 
- MoodLamp 1ea 

이중 DoorLock 과 Curtain 읜 Auto 제어기의 GPIO에 연결되어 있으며 나머지 장치는 I2C 인터페이스를 통해 PWM Controller 에 연결되어 있습니다. 16채널인 PWM Controller 는 2개가 활용되고 있으며 각각 1층과 2층에 1개씩 위치하고 있습니다. 아래는 각 층별 PWM Controller 에 연결된 장치의 정보입니다. 

---
#### 1층 PWM Controller 
- I2C Bus : 0
- I2C Slave Address : 0x40 

| Channel | Function | Active |
|:-------:|:------|:------:|
| 0 | Livingroom Lamp | HIGH | 
| 2 | Livingroom Fan | HIGH | 
| 3 | Kitchen Fan | HIGH | 
| 4 | Kitchen Lamp | HIGH | 
| 5 | Kitchen GasBreaker | HIGH | 
| 7 | Entrance Lamp | HIGH | 

---
#### 2층 PWM Controller 
- I2C Bus : 1
- I2C Slave Address : 0x50 

| Channel | Function | Active |
|:-------:|:------|:------:|
| 0 | Room Lamp | HIGH | 
| 1 | Room Fan | HIGH | 
| 3 | Bathroom Lamp | HIGH | 
| 4 | Bathroom Fan | HIGH | 
| 5 | MoodLamp RED | HIGH | 
| 6 | MoodLamp GREEN | HIGH | 
| 7 | MoodLamp BLUE | HIGH | 

---

#### DoorLock 
DoorLock 은 GPIO 와 연결되어 있으며 4개의 GPIO와 연결되어 있습니다. STEP 모터를 제어하며 2상 여자 방식을 이용해 제어합니다. 연결되어 있는 GPIO의 정보는 다음과 같습니다. 

| GPIO | Function |
|:-------:|:------:|
| 14 | A |
| 15 | B |
| 16 | /A | 
| 17 | /B | 
 
 ---

 #### Curtain 
 Curtain 은 모터 컨트롤러를 통해 제어되며, 방향신호를 담당하는 GPIO 와 동작 신호를 담당하는 GPIO 2개가 연결되어 있습니다. 

| GPIO | Function |
|:-------:|:------:|
| 20 | Direction |
| 21 | Enable |
 
 ---

### 센서 연결 구성 
XHome 에 장착되어 있는 센서는 7종입니다. 대부분의 센서는 I2C 인터페이스를 활용하며, Gas, PIR, Reed 만이 GPIO와 연결되어 있습니다. 

#### I2C 인터페이스를 활용한 센서 
I2C 인터페이스를 활용하는 센서의 목록과 주소는 다음과 같습니다. 
- Dust 
    - I2C Bus : 0
    - I2C Slave Address : 0x28 
- TPHG 
    - I2C Bus : 1 
    - I2C Slave Address : 0x77 
- Accelometer
    - I2C Bus : 1 
    - I2C Slave Address : 0x53
- Light 
    - I2C Bus : 1 
    - I2C Slave Address : 0x5C 

---

#### GPIO 와 연결된 센서 
GPIO 와 연결된 센서는 PIR, Reed, Gas 이며 이중 Gas 는 ADC를 활용합니다. 

| GPIO | Function |
|:-------:|:------:|
| 7 | PIR |
| 8 | Reed |
| 26 | Gas |

## PIR 센서 모니터링 
Auto 제어기를 활용한 PIR 센서의 값을 모니터링 하는 프로그램 입니다. PIR 센서는 GPIO 7과 연결되어 있고 이 GPIO 의 상태를 읽는것으로 센서 감지 여부를 확인할 수 있습니다. MicroPython 에서 GPIO 는 machine 의 Pin 을 통해 모드를 Input 또는 Output으로 설정할 수 있으며, 이를 활용하여 PIR 센서의 값을 읽는 클래스를 구현합니다. 

```python
from machine import Pin
import time 

class Pir:
    def __init__(self, pin=7):
        self.__pin = Pin(pin,Pin.IN)

    def read(self):
        return self.__pin.value()

pir = Pir() 
for i in range(30):
    print(pir.read())
    time.sleep(0.1)
```

작성된 프로그램은 upy 명령을 통해 Auto 제어기에서 실행 하도록 합니다. 아래는 upy 명령을 통해 작성한 프로그램을 실행하는 명령입니다. 여기서 "COM PORT" 는 실행하는 운영체제에 따라 명칭이 다를 수 있습니다. 윈도우에서는 COM1, COM2 등의 이름을, 리눅스에서는 '/dev/ttyACM0' 등의 이름으로 장치가 인식됩니다. 연결한 PC의 상황에 맞춰 포트의 명칭을 정확하게 입력해야 합니다. 

```sh
> upy -s <COM PORT> run pir.py 
ex) upy -s COM15 run pir.py 
0
1
1
0
0
0
1
0
```

## Lamp 제어 

```python
from pop.actuator import PwmController
import time 

class Lamp:
    F1_IDS = {    
        'door': 8, 
        'living': 0,
        'kitchen': 4
    }
    F2_IDS = {    
        'room': 0,
        'bathroom': 3
    }
    def __init__(self):
        self.__dev1 = PwmController()
        self.__dev1.freq(50)
        self.__dev2 = PwmController(bus=1,address=0x50)
        self.__dev2.freq(50)

    def on(self, target=None):
        if target is None: 
            for i in self.F1_IDS.values():
                self.__dev1.duty(index=i,value=4095)
            for i in self.F2_IDS.values():
                self.__dev2.duty(index=i,value=4095)
        elif type(target) == (list or tuple):
            for i in target:
                for key in self.F1_IDS.keys():
                    if i == key:
                        self.__dev1.duty(index=self.F1_IDS[key],value=4095)
            for i in target:
                for key in self.F2_IDS.keys():
                    if i == key:
                        self.__dev2.duty(index=self.F2_IDS[key],value=4095)
        elif type(target) == str:
            for key in self.F1_IDS.keys():
                if target == key:
                    self.__dev1.duty(index=self.F1_IDS[key],value=4095)
            for key in self.F2_IDS.keys():
                if target == key:
                    self.__dev2.duty(index=self.F2_IDS[key],value=4095)

    def off(self, target=None):
        if target is None: 
            for i in self.F1_IDS.values():
                self.__dev1.duty(index=i,value=0)
            for i in self.F2_IDS.values():
                self.__dev2.duty(index=i,value=0)
        elif type(target) == (list or tuple):
            for i in target:
                for key in self.F1_IDS.keys():
                    if i == key:
                        self.__dev1.duty(index=self.F1_IDS[key],value=0)
            for i in target:
                for key in self.F2_IDS.keys():
                    if i == key:
                        self.__dev2.duty(index=self.F2_IDS[key],value=0)
        elif type(target) == str:
            for key in self.F1_IDS.keys():
                if target == key:
                    self.__dev1.duty(index=self.F1_IDS[key],value=0)
            for key in self.F2_IDS.keys():
                if target == key:
                    self.__dev2.duty(index=self.F2_IDS[key],value=0)

lamp = Lamp() 
lamp.on()
time.sleep(2)
lamp.off()
time.sleep(2)

for key in lamp.F1_IDS.keys():
    print(key)
    lamp.on(key)
    time.sleep(2)
    lamp.off(key)
    time.sleep(2)

for key in lamp.F2_IDS.keys():
    print(key)
    lamp.on(key)
    time.sleep(2)
    lamp.off(key)
    time.sleep(2)
```


<details>
<summary>Lamp 제어 심화</summary>

```python
from machine import I2C, Pin
import ustruct, time 

class PwmController:
    def __init__(self, bus=0, address=0x40):
        if bus == 0:
            self.__i2c = I2C(id=0,sda=Pin(4),scl=Pin(5))
        elif bus == 1:
            self.__i2c = I2C(id=1,sda=Pin(2),scl=Pin(3))
        self.__address = address 
        self.reset()

    def _write(self, address, value):
        self.__i2c.writeto_mem(self.__address, address, bytearray([value]))

    def _read(self, address):
        return self.__i2c.readfrom_mem(self.__address, address, 1)[0]

    def reset(self):
        self._write(0x00, 0x00)

    def freq(self, freq=None):
        if freq is None:
            return int(25000000.0 / 4096 / (self._read(0xfe) - 0.5))
        prescale = int(25000000.0 / 4096.0 / freq + 0.5)
        old_mode = self._read(0x00)
        self._write(0x00, (old_mode & 0x7F) | 0x10)
        self._write(0xfe, prescale) 
        self._write(0x00, old_mode)
        time.sleep_us(5)
        self._write(0x00, old_mode | 0xa1) 

    def pwm(self, index, on=None, off=None):
        if on is None or off is None:
            data = self.i2c.readfrom_mem(self.__address, 0x06 + 4 * index, 4)
            return ustruct.unpack('<HH', data)
        data = ustruct.pack('<HH', on, off)
        self.__i2c.writeto_mem(self.__address, 0x06 + 4 * index,  data)

    def duty(self, index, value=None, invert=False):
        if value is None:
            pwm = self.pwm(index)
            if pwm == (0, 4096):
                value = 0
            elif pwm == (4096, 0):
                value = 4095
            value = pwm[1]
            if invert:
                value = 4095 - value
            return value
        if not 0 <= value <= 4095:
            raise ValueError("Out of range")
        if invert:
            value = 4095 - value
        if value == 0:
            self.pwm(index, 0, 4096)
        elif value == 4095:
            self.pwm(index, 4096, 0)
        else:
            self.pwm(index, 0, value)

class Lamp:
    F1_IDS = {    
        'door': 8, 
        'living': 0,
        'kitchen': 4
    }
    F2_IDS = {    
        'room': 0,
        'bathroom': 3
    }
    def __init__(self):
        self.__dev1 = PwmController()
        self.__dev1.freq(50)
        self.__dev2 = PwmController(bus=1,address=0x50)
        self.__dev2.freq(50)

    def on(self, target=None):
        if target is None: 
            for i in self.F1_IDS.values():
                self.__dev1.duty(index=i,value=4095)
            for i in self.F2_IDS.values():
                self.__dev2.duty(index=i,value=4095)
        elif type(target) == (list or tuple):
            for i in target:
                for key in self.F1_IDS.keys():
                    if i == key:
                        self.__dev1.duty(index=self.F1_IDS[key],value=4095)
            for i in target:
                for key in self.F2_IDS.keys():
                    if i == key:
                        self.__dev2.duty(index=self.F2_IDS[key],value=4095)
        elif type(target) == str:
            for key in self.F1_IDS.keys():
                if target == key:
                    self.__dev1.duty(index=self.F1_IDS[key],value=4095)
            for key in self.F2_IDS.keys():
                if target == key:
                    self.__dev2.duty(index=self.F2_IDS[key],value=4095)

    def off(self, target=None):
        if target is None: 
            for i in self.F1_IDS.values():
                self.__dev1.duty(index=i,value=0)
            for i in self.F2_IDS.values():
                self.__dev2.duty(index=i,value=0)
        elif type(target) == (list or tuple):
            for i in target:
                for key in self.F1_IDS.keys():
                    if i == key:
                        self.__dev1.duty(index=self.F1_IDS[key],value=0)
            for i in target:
                for key in self.F2_IDS.keys():
                    if i == key:
                        self.__dev2.duty(index=self.F2_IDS[key],value=0)
        elif type(target) == str:
            for key in self.F1_IDS.keys():
                if target == key:
                    self.__dev1.duty(index=self.F1_IDS[key],value=0)
            for key in self.F2_IDS.keys():
                if target == key:
                    self.__dev2.duty(index=self.F2_IDS[key],value=0)

lamp = Lamp() 
lamp.on()
time.sleep(2)
lamp.off()
time.sleep(2)

for key in lamp.F1_IDS.keys():
    print(key)
    lamp.on(key)
    time.sleep(2)
    lamp.off(key)
    time.sleep(2)

for key in lamp.F2_IDS.keys():
    print(key)
    lamp.on(key)
    time.sleep(2)
    lamp.off(key)
    time.sleep(2)
```

```sh
> upy -s <COM PORT> run fan.py 
ex) upy -s COM15 run fan.py 
door
living
kitchen
room
bathroom
```
</details>


## Dust 센서 모니터링 

```python
from machine import I2C, Pin
import time 

class Dust:
    def __init__(self, i2c=None, address=0x28):
        if i2c is None:
            self.__i2c = I2C(0,sda=Pin(4),scl=Pin(5))
        else:
            self.__i2c = i2c
        self.__address = address
        self.__recvBuf = [None]*32
        self.sensor_status = 0
        self.measuring_mode = 0
        self.calibration_factor = 0
        self.data = [None]*3 
        self.reset()

    def reset(self):
        resetData = bytes([0x16,0x7,0x03,0xff,0xff,0x00,0x16])
        self.__i2c.writeto(self.__address,resetData)

    def read(self, grimm=False):
        self.__recvBuf = self.__i2c.readfrom(self.__address,32)
        if self.__recvBuf[0] == 0x16:
            if self.__recvBuf[1] == 32:
                check = self.__recvBuf[0]
                for i in range(30):
                    check = check ^ self.__recvBuf[i+1]
                if check == self.__recvBuf[-1]:
                    self.sensor_status = self.__recvBuf[2]
                    self.measuring_mode = (self.__recvBuf[3]<<8)|self.__recvBuf[4]
                    self.calibration_factor = (self.__recvBuf[5]<<8)|self.__recvBuf[6]
                    if grimm == True:
                        #grimm 1.0
                        self.data[0] = (self.__recvBuf[7]<<8)|self.__recvBuf[8] 
                        #grimm 2.5
                        self.data[1] = (self.__recvBuf[9]<<8)|self.__recvBuf[10] 
                        #grimm 10
                        self.data[2] = (self.__recvBuf[11]<<8)|self.__recvBuf[12] 
                    else:
                        #tsi 1.0 
                        self.data[0] = (self.__recvBuf[13]<<8)|self.__recvBuf[14] 
                        #tsi 2.5
                        self.data[1] = (self.__recvBuf[15]<<8)|self.__recvBuf[16] 
                        #tsi 10
                        self.data[2] = (self.__recvBuf[17]<<8)|self.__recvBuf[18]  
        return self.data
    
dust = Dust() 
for i in range(30):
    print(dust.read())
    time.sleep(1)
```

```sh 
> upy -s <COM PORT> run dust.py 
ex) upy -s COM15 run dust.py 
[12, 13, 13]
[12, 13, 14]
[13, 16, 19]
[13, 18, 23]
[13, 18, 23]
[13, 18, 23]
[13, 18, 23]
[13, 18, 24]
[13, 18, 24]
```

## 상태머신을 활용한 DoorLock 제어 

```python
import time, rp2
from machine import Pin

@rp2.asm_pio(set_init=(rp2.PIO.OUT_LOW,) * 4) 
def doorlock_open():
    wrap_target()
    set(pins, 0b1100) [7]  
    set(pins, 0b0110) [7]  
    set(pins, 0b0011) [7]  
    set(pins, 0b1001) [7]  
    wrap()

@rp2.asm_pio(set_init=(rp2.PIO.OUT_LOW,) * 4)
def doorlock_close():
    wrap_target()
    set(pins, 0b0011) [7]  
    set(pins, 0b0110) [7]  
    set(pins, 0b1100) [7]  
    set(pins, 0b1001) [7]  
    wrap()

class DoorLock:
    OPEN = 1
    CLOSE = 2 
    def __init__(self):
        self.status = None
        self.sm_open = rp2.StateMachine(0, doorlock_open, freq=4000, set_base=Pin(14))
        self.sm_close = rp2.StateMachine(1, doorlock_close, freq=4000, set_base=Pin(14))
        self.status = None

    def open(self):
        if self.status is not self.OPEN:
            self.status = self.OPEN
            self.sm_close.active(0)
            self.sm_open.active(1)

    def close(self):
        if self.status is not self.CLOSE:
            self.status = self.CLOSE
            self.sm_open.active(0)
            self.sm_close.active(1)

    def stop(self):
        self.sm_open.active(0)
        self.sm_close.active(0)

doorlock = DoorLock()
doorlock.open()
time.sleep(1)
doorlock.stop()
time.sleep(1)
doorlock.close()
time.sleep(1)
doorlock.stop()
```

```sh
> upy -s <COM PORT> run doorlock.py 
ex) upy -s COM15 run doorlock.py 
```