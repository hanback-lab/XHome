# MQTT
MQTT(Message Queue Telemetry Transport)는 앤디 스텐포드-클락andy stanford-clark(IBM)과 알렌 니퍼arlen nipper가 인공위성을 통해 오일 파이프라인 원격 검침 시스템을 연결하기 위해 1999년부터 설계한 것으로 2010년 로열티 없는 상태로 출시되어 2014년 표준이 되었습니다. 이후 MQTT V3.1 및 V3.1.1을 중심으로 IoT(Internet of Things) 장치 사이 낮은 대역폭 통신을 제공하는 가벼운 메시징 프로토콜 중 하나로 자리매김하고 있으며 2018년 1월 최신 버전인 MQTT V5가 승인된 상태입니다.

MQTT 시스템은 중계 서버 역할의 브로커broker와 브로커에 토픽을 기반으로 메시지를 보내고 받는 클라이언트로 구성되는데, 클라이언트는 브로커로부터 토픽 메시지를 구독하는 구독자subscriber와 토픽에 메시지를 발행하는 발행자publisher로 나누어집니다.

## MQTT 개요 
MQTT는 TCP/IP를 기반으로 한 메시지 버스 시스템으로 클라이언트(발행자, 구독자)와 서버(브로커), 세션, 서브스크립션, 토픽으로 구성되며, 게시/구독 모델을 사용하여 메시징을 수행하는 간단한 방법을 제공합니다. 따라서 저전력 센서나 전화기, 내장형 컴퓨터 또는 마이크로 컨트롤러와 같은 모바일 장치를 사용하는 사물 인터넷 메시징에 적합합니다.

![MQTT Architecture](res/MQTT%20Architecture.png)

### MQTT 브로커 
브로커는 TCP 포트 1883을 사용하는 일종의 서버 프로그램으로 발행자와 구독자 사이 중계자 역할만 하므로 서버 대신 브로커란 용어를 사용합니다. 브로커가 발행자로부터 메시지를 수신하면 토픽을 기반으로 이를 게시한 후 토픽에 가입한 모든 구독자에게 배포합니다. 기본적으로 게시된 메시지 중 가입자가 없는 메시지나 배포된 메시지는 제거되지만 보존 속성을 가진 메시지나 영구 세션에서 발행한 메시지는 최소한 다음 배포까지 유지됩니다.

브로커는 IBM MQ와 같은 상용 제품부터 EMQ, mosquitto와 같은 오픈소스에 이르기까지 다양한 제품들이 있는데, 이 중 이클립스 재단에서 배포하는 mosquitto는 MQTT V5.0 프로토콜까지 지원하며, 가볍고 빨라 라즈베리파이와 같은 저전력 단일 보드 컴퓨터부터 서버에 이르기까지 모든 장치에 사용하기 적합니다.

다음은 운영체제 별로 mosquitto 브로커를 설치하는 방법입니다.

- Linux
```sh 
sudo apt install mosquitto  
```
- Windows 
```sh 
winget install EclipseFoundation.Mosquitto
```
- macOS
```sh
brew install mosquitto 
```

설치가 완료되면 mosquitto는 백그라운드 서비스로 동작하는데, 윈도우에서는 사용자가 작업 관리자의 서비스 탭 또는 서비스 관리자를 실행한 후 mosquitto 항목을 찾아 컨텍스트 메뉴(마우스 우클릭)에서 시작을 선택해야 합니다.
또한 설정 파일인 mosquitto.conf를 편집해 외부 접속 허용, 익명 허용, 보안 로그인과 같은 각종 설정을 변경할 수 있습니다.

- 리눅스: /etc/mosquitto/conf.d/
- 윈도우: mosquitto 설치 폴더

공개용 브로커 간단한 테스트가 목적이라면 브로커를 자신의 컴퓨터에 설치하지 않고 인터넷 클라우드를 통해 무료로 사용할 수 있는 공개용 브로커를 사용해도 됩니다. 특히 공개용 브로커는 인터넷을 통해 언제 어디서든 접속이 가능하므로 사설 주소를 사용하는 환경에서는 매우 유용한 선택입니다.

| Name | Broker Address | TCP Port | TLS Port | WebSocket Port| Message Retention |
|:---|:---|:---|:---|:---|:---|
| Eclipse | mqtt.eclipse.org | 1883	| N/A | 80, 443 | YES |
| Mosquitto | test.mosquitto.org | 1883	| 8883, 8884 | 80 | YES |
| HiveMQ | broker.hivemq.com | 1883	| N/A | 8000 | YES |
| Flespi | mqtt.flespi.io | 1883 | 8883 | 80, 443 | YES |
| Dioty	| mqtt.dioty.co | 1883 | 8883 |	8080, 8880 | YES |
| Fluux	| mqtt.fluux.io | 1883 | 8883 | N/A | N/A |
| EMQX | broker.emqx.io | 1883 | 8883| 8083 | YES | 

### MQTT 클라이언트 
해당 장치가 발행자면 토픽에 대한 메시지를 발행해 브로커에 게시할 수 있고 구독자면 브로커의 특정 토픽에 가입해 메시지를 구독할 수 있습니다. 하나의 클라이언트는 구독자 또는 발행자이거나 모두일 수 있습니다. 선택적으로 보안 기능을 활성화면 브로커에 연결할 때 사용자 ID와 비밀번호 또는 인증서를 이용해 인증합니다.

클라이언트는 일반적으로 공개된 MQTT 클라이언트 라이브러리를 이용해 구현하지만 이클랩스 재단에서 mosquitto와 함께 제공하는 mosquitto-clients 나 EMQX의 MQTTX 처럼 범용으로 구현된 프로그램들도 있습니다. 특히 MQTTX는 운영체제 별로 GUI 및 CLI을 지원하며, 웹 환경까지 지원해 상황에 맞게 선택할 수 있습니다.

MQTTX 설치 프로그램은 다음 링크를 통해 다운로드 받아 쉽게 설치할 수 있습니다. 
- [MQTTX](https://mqttx.app/downloads)

### 토픽
토픽은 메시지에 대한 발생/구독 패턴의 기준으로 클라이언트 사이 미리 정의한 의미대로 정보를 교환할 수 있게 합니다. 대소 문자를 구분하는 계층 구조의 UTF-8 문자열로 파일 시스템의 경로와 같이 슬래시(/)로 구분되며 발행자와 브로커, 브로커와 구독자 사이 토픽에 따른 메시지 흐름을 구분합니다.

#### 토픽 구조 
$SYS 토픽을 제외하고 기본 또는 표준화된 토픽 구조는 없습니다. $SYS 토픽은 브로커에 대한 정보를 공개하기 위해 대부분의 브로커에서 예약되어 있습니다.

![](res/Topic.png)

앞의 그림의 토픽은 3개의 레벨로 구성되어 있습니다. 첫번째는 Sensor, 두번째는 imu, 세번째는 value 입니다. 

#### 토픽 생성 및 제거 
발행자는 메시지를 발행할 때마다 토픽을 포함하므로 브로커는 토픽이 없으면 만든 후 게시합니다. 또한 구독자도 토픽에 가입할 때 토픽이 없으면 브로커는 만든 후 가입시킵니다. 토픽은 세션이 제거될 때 제거됩니다.

#### 토픽 필터 
발행자가 토픽에 메시지를 게시할 때는 항상 개별적인 발행만 허용하므로 두 가지 토픽에 메시지를 게시하려면 두 번 발행해야 합니다. 하지만 구독자는 여러 토픽에 가입하는 대신 토픽 필터를 적용해 한 번만 가입해도 됩니다. 토픽 필터는 단일 레벨 필터일 '+'와 다중 레벨 필터인 '#' 중 하나를 이용해 레벨 또는 이후 모든 레벨을 와일드카드wildcard로 설정합니다.

- +: 단일 레벨 와일드카드로 레벨의 모든 문자 치환
- #: 다중 레벨 와일드카드로 현재 레벨과 이후 모든 레벨의 문자 치환
    - $SYS/#: 브로커의 모든 토픽에 가입

아래와 같은 토픽이 있다고 가정하겠습니다. 

- Sensor/imu/value
- Sensor/ultrasonic/distance
- Sensor/cds/value

이 때 Sensor 와 value 포함된 토픽을 구독한다면 다음과 같이 필터를 적용할 수 있습니다. 

- Sensor/+/value

Sensor 하위 모든 토픽을 구독하는 경우에는 다음과 같이 적용합니다. 

- Sensor/# 

### 세션 
세션은 연결된 클라이언트와 브로커 사이 상호작용을 관리하기 위한 것으로 클라이언트와 브로커는 세션 정보 중 서비스 품질을 나타내는 QoS를 통해 "적어도 한 번" 및 "정확히 한 번" 발행과 "정확히 한 번" 구독을 보장합니다. 또한 구독자가 작성한 구독도 세션 정보에 포함됩니다.

다음은 세션에 저장되는 내용입니다.

- 구독이 없는 세션의 존재 여부
- 모든 구독
- 클라이언트가 확인하지 않은 QoS = 1 또는 QoS = 2 메시지
- 클라이언트가 끊어진 동안 놓친 모든 새로운 QoS = 1 또는 QoS = 2 메시지
- 클라이언트에서 아직 확인되지 않은 모든 수신된 QoS = 2 메시지

클라이언트를 연결할 때 이전 세션 정보를 유지하거나 유지하지 않도록 선택할 수 있는데, 영구 세션(CleanSession = False)은 세션 상태를 유지하고 클린 세션(CleanSession = True)은 유지하지 않습니다.

클라이언트가 클라이언트 ID와 브로커 주소, 클린 세션 여부, 사용자 ID, 비밀번호 또는 인증서를 이용해 브로커에 연결을 요청하면 브로커는 세션 정보가 이전 연결에서 저장되어 있는지 확인합니다. 이전 세션이 존재할 때 클린 세션이면 클라언트와 브로커의 이전 세션 상태는 지워지고 영구 세션이면 이전 세션 상태를 다시 사용합니다. 이전 세션이 없으면 새 세션이 시작됩니다.


### MQTT 클라이언트 라이브러리 

# MQTT 응용 

## 단방향 클라이언트 

## 양방향 클라이언트 

## 콜백 이벤트 

### 발행 콜백 

### 수신 콜백 

### JSON 메시지 